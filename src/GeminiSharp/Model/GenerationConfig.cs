/*
 * Google Gemini API
 *
 * Comprehensive API for interacting with Google's Gemini models supporting text, chat, image generation, file uploads, grounding, code execution, model tuning, and more.
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = GeminiSharp.Client.FileParameter;
using OpenAPIDateConverter = GeminiSharp.Client.OpenAPIDateConverter;

namespace GeminiSharp.Model
{
    /// <summary>
    /// GenerationConfig
    /// </summary>
    [DataContract(Name = "GenerationConfig")]
    public partial class GenerationConfig : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="GenerationConfig" /> class.
        /// </summary>
        /// <param name="stopSequences">The set of character sequences that will stop output generation.</param>
        /// <param name="responseMimeType">Output format of the generated candidate text.</param>
        /// <param name="responseSchema">Output schema of the generated candidate text when response_mime_type is application/json.</param>
        /// <param name="candidateCount">Number of generated responses to return.</param>
        /// <param name="maxOutputTokens">The maximum number of tokens to include in a response candidate.</param>
        /// <param name="temperature">Controls the randomness of the output.</param>
        /// <param name="topP">The maximum cumulative probability of tokens to consider when sampling.</param>
        /// <param name="topK">The maximum number of tokens to consider when sampling.</param>
        /// <param name="presencePenalty">Presence penalty applied to the next token&#39;s logprobs.</param>
        /// <param name="frequencyPenalty">Frequency penalty applied to the next token&#39;s logprobs.</param>
        /// <param name="responseLogprobs">If true, export the logprobs results in response.</param>
        /// <param name="logprobs">Only valid if responseLogprobs is True.</param>
        public GenerationConfig(Collection<string> stopSequences = default, string responseMimeType = default, Object responseSchema = default, int candidateCount = default, int maxOutputTokens = default, float temperature = default, float topP = default, int topK = default, float presencePenalty = default, float frequencyPenalty = default, bool responseLogprobs = default, int logprobs = default)
        {
            this.StopSequences = stopSequences;
            this.ResponseMimeType = responseMimeType;
            this.ResponseSchema = responseSchema;
            this.CandidateCount = candidateCount;
            this.MaxOutputTokens = maxOutputTokens;
            this.Temperature = temperature;
            this.TopP = topP;
            this.TopK = topK;
            this.PresencePenalty = presencePenalty;
            this.FrequencyPenalty = frequencyPenalty;
            this.ResponseLogprobs = responseLogprobs;
            this.Logprobs = logprobs;
        }

        /// <summary>
        /// The set of character sequences that will stop output generation
        /// </summary>
        /// <value>The set of character sequences that will stop output generation</value>
        [DataMember(Name = "stopSequences", EmitDefaultValue = false)]
        public Collection<string> StopSequences { get; set; }

        /// <summary>
        /// Output format of the generated candidate text
        /// </summary>
        /// <value>Output format of the generated candidate text</value>
        [DataMember(Name = "responseMimeType", EmitDefaultValue = false)]
        public string ResponseMimeType { get; set; }

        /// <summary>
        /// Output schema of the generated candidate text when response_mime_type is application/json
        /// </summary>
        /// <value>Output schema of the generated candidate text when response_mime_type is application/json</value>
        [DataMember(Name = "responseSchema", EmitDefaultValue = false)]
        public Object ResponseSchema { get; set; }

        /// <summary>
        /// Number of generated responses to return
        /// </summary>
        /// <value>Number of generated responses to return</value>
        [DataMember(Name = "candidateCount", EmitDefaultValue = false)]
        public int CandidateCount { get; set; }

        /// <summary>
        /// The maximum number of tokens to include in a response candidate
        /// </summary>
        /// <value>The maximum number of tokens to include in a response candidate</value>
        [DataMember(Name = "maxOutputTokens", EmitDefaultValue = false)]
        public int MaxOutputTokens { get; set; }

        /// <summary>
        /// Controls the randomness of the output
        /// </summary>
        /// <value>Controls the randomness of the output</value>
        [DataMember(Name = "temperature", EmitDefaultValue = false)]
        public float Temperature { get; set; }

        /// <summary>
        /// The maximum cumulative probability of tokens to consider when sampling
        /// </summary>
        /// <value>The maximum cumulative probability of tokens to consider when sampling</value>
        [DataMember(Name = "topP", EmitDefaultValue = false)]
        public float TopP { get; set; }

        /// <summary>
        /// The maximum number of tokens to consider when sampling
        /// </summary>
        /// <value>The maximum number of tokens to consider when sampling</value>
        [DataMember(Name = "topK", EmitDefaultValue = false)]
        public int TopK { get; set; }

        /// <summary>
        /// Presence penalty applied to the next token&#39;s logprobs
        /// </summary>
        /// <value>Presence penalty applied to the next token&#39;s logprobs</value>
        [DataMember(Name = "presencePenalty", EmitDefaultValue = false)]
        public float PresencePenalty { get; set; }

        /// <summary>
        /// Frequency penalty applied to the next token&#39;s logprobs
        /// </summary>
        /// <value>Frequency penalty applied to the next token&#39;s logprobs</value>
        [DataMember(Name = "frequencyPenalty", EmitDefaultValue = false)]
        public float FrequencyPenalty { get; set; }

        /// <summary>
        /// If true, export the logprobs results in response
        /// </summary>
        /// <value>If true, export the logprobs results in response</value>
        [DataMember(Name = "responseLogprobs", EmitDefaultValue = true)]
        public bool ResponseLogprobs { get; set; }

        /// <summary>
        /// Only valid if responseLogprobs is True
        /// </summary>
        /// <value>Only valid if responseLogprobs is True</value>
        [DataMember(Name = "logprobs", EmitDefaultValue = false)]
        public int Logprobs { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class GenerationConfig {\n");
            sb.Append("  StopSequences: ").Append(StopSequences).Append("\n");
            sb.Append("  ResponseMimeType: ").Append(ResponseMimeType).Append("\n");
            sb.Append("  ResponseSchema: ").Append(ResponseSchema).Append("\n");
            sb.Append("  CandidateCount: ").Append(CandidateCount).Append("\n");
            sb.Append("  MaxOutputTokens: ").Append(MaxOutputTokens).Append("\n");
            sb.Append("  Temperature: ").Append(Temperature).Append("\n");
            sb.Append("  TopP: ").Append(TopP).Append("\n");
            sb.Append("  TopK: ").Append(TopK).Append("\n");
            sb.Append("  PresencePenalty: ").Append(PresencePenalty).Append("\n");
            sb.Append("  FrequencyPenalty: ").Append(FrequencyPenalty).Append("\n");
            sb.Append("  ResponseLogprobs: ").Append(ResponseLogprobs).Append("\n");
            sb.Append("  Logprobs: ").Append(Logprobs).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
